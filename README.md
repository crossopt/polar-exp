# polar-exp

Исследования декодирования полярных кодов с помощью belief propagation на примере binary erasure channel.

### Модель данных для кодирования:

#### Изначальные данные
Имеется n = 2^k переменных с индексами от 0 до 2^(k - 1). Каждая переменная равна либо 0, либо 1.

#### Полярное кодирование
Всего в кодировании k = log n шагов. На шаге i для всех индексов переменных a, b, различающихся толькол в i-ом бите, вычисляются гейты (a, b) -> (a xor b, b). При этом с вероятностью p данные теряются и вместо значения передается '?'.

#### Frozen bits
np переменным с наименьшей вероятностью успешной передачи изначально присваивается фиксированное значение. Такие переменные называются замороженными, или frozen.

#### Итоговые данные
На выходе имеются n = 2^k переменных, каждой из которых присвоено либо переданное значение, либо '?'. Матожидание количество потерянных значений np.

### Модель данных для декодирования:

#### Граф декодирования
Удобно рассматривать посчитанные при кодировании значения как вершины графа, а гейты, соответственно, как ребра. В таком графе у вершинам, соответствующим изначальным значениям и итоговым значениям степень 1, а у всех остальных вершин степень 3. Граф разделен на слои, где в каждом слое ровно n вершин.

#### Состояния '\*' и '?' 
Поскольку для анализа сходимости декодирования реальные значения кодов не важны, мы будем только различать состояния '\*' (значение известно) и '?' (значение неизвестно). До начала декодирования для изначальных данных известны np frozen bits, а для итоговых известны корректно переданные значения. В нашей модели мы допускаем, что их n(1 - p).

Состояния соответствуют ребрам графа декодирования. На внешних ребрах, соединенных с изначальными и итоговыми значениями, состояния проставляются в соответствии с их значениями. На внутренних ребрах изначальное состояние равно '?'.

#### Типы внутренних гейтов и правила декодирования
Внутренние вершины графа делятся на два типа: "верх" и "низ", в зависимости от того, как они были получены при кодировании.

- Узлы типа "верх" соответствуют значению, равному xor двух значений на предыдушем слое.

xor двух значений определяет результат, поэтому при декодировании, если узлу типа "верх" инцидентны два ребра c меткой '\*', третьему можно тоже присвоить '\*'.

- Узлы типа "верх" соответствуют значению, равному значению на предыдушем слое.

Все значения в этом гейте одинаковы, значит одно любое определяет их все. Поэтому при декодировании, если узлу типа "низ" инцидентно ребро c меткой '\*', остальным можно тоже присвоить '\*'.

На основании этих двух правил можно декодировать код, то есть проставить всем ребрам графа значение метки '\*'. Мы стремимся исследовать сходимость этого процесса.
