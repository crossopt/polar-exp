# polar-exp

Исследования декодирования полярных кодов с помощью belief propagation на примере binary erasure channel.

### Модель данных для кодирования:

#### Изначальные данные
Имеется n = 2^k переменных с индексами от 0 до 2^k - 1. Значение каждой переменной равно либо 0, либо 1.

#### Полярное кодирование
Всего в кодировании k = log n шагов. На шаге i для всех индексов переменных a, b, различающихся только в i-ом бите, выполняются вычислительные элементы (a, b) -> (a xor b, b).

После кодирования с вероятностью p данные теряются при передаче через канал, и в таком случае вместо значения переменной будет принято '?'.

#### Замороженные биты
np изначальным переменным присваиваются фиксированные значения и такие переменные называются замороженными, или frozen. В качестве замороженных переменных выбираются те, у которых вероятность успешного декодирования из частично потерянных данных наименьшая.

#### Итоговые данные
На выходе имеются n = 2^k переменных, каждой из которых присвоено либо переданное значение, либо '?'. Матожидание количества потерянных значений равно np.

### Модель данных для декодирования:

#### Граф кодирования
Удобно рассматривать применяемые при кодировании операции как вершины графа. Граф разделен на слои, соответствующие шагам кодирования, где в каждом слое ровно n вершин.

В таком графе будут ребра двух видов: горизонтальные и вертикальные.

- Вертикальные рёбра соединяют вершины, находящиеся в одном слое. Они соответствуют вычислительному элементу кодирования.

- Горизонтальные ребра соединяют вершины, находящиеся в соседних слоях. Они соответствуют передаче значения переменной на следующий шаг кодирования.

В таком графе вершины будут соответствовать применению операции при кодировании, где вертикальные ребра соединяют вершину, выполняющую операцию копирования с вершиной, выполняющей операцию xor.

Дополнительно добавим вершины, соответствующие изначальным переменным и итоговым переменным. У этих вершин будет степень 1, а у всех остальных вершин степень 3. Из вершин степени 3 выходят два горизонтальных ребра и одно вертикальное.

#### Состояния '\*' и '?' 
Поскольку для анализа сходимости декодирования реальные значения кодов не важны, мы будем только различать состояния '\*' (значение известно) и '?' (значение неизвестно). До начала декодирования для изначальных данных известны np замороженных переменных, а для итоговых известны переменные с корректно принятыми значениями. В нашей модели мы допускаем, что их n(1 - p).

Состояния проставлены на ребрах графа кодирования. На внешних ребрах, соединенных с изначальными и итоговыми переменными, состояния проставляются в соответствии с их значениями. На внутренних ребрах изначальное состояние равно '?'.

#### Типы внутренних вершин и правила декодирования
Внутренние вершины графа делятся на два типа: "верх" и "низ", в зависимости от операции, которой они соответствуют.

- Вершины типа "верх" соответствуют применению операции xor.

Из трех значений a, b, a xor b любые два определяют третье, поэтому при декодировании, если вершине типа "верх" инцидентны два ребра c состоянием '\*', третьему можно тоже присвоить '\*'.

- Вершины типа "низ" соответствуют применению операции копирования.

Все значения в этой вершине одинаковы, значит одно любое определяет их все. Поэтому при декодировании, если вершине типа "низ" инцидентно ребро c состояниям '\*', остальным можно тоже присвоить '\*'.

Для случая binary erasure channel на основании этих двух правил можно декодировать код, то есть проставить всем ребрам графа значение состояния '\*'. Мы стремимся исследовать сходимость этого процесса.

### Реализованные методы декодирования

#### Naive

"Наивный" метод декодирования. Декодирование состоит из некоторого числа итераций. На каждой итерации параллельно применяются правила во всех внутренних вершинах.

#### Conventional scheduling

Декодирование состоит из некоторого числа итераций, а каждая итерация состоит из k шагов. На i-м шаге итерации параллельно применяются правила во всех вершинах i-го внутреннего слоя.

Этот метод работает лучше, чем наивный, но всё равно местами неэффективен и выполняет лишнюю работу. Например, неоптимально на первом шаге пытаться обновить значение внешнего ребра до обновления внутренних ребер на втором шаге.

#### Round-trip scheduling

Декодирование состоит из некоторого числа итераций, а каждая итерация состоит из 2k шагов. Сначала на каждом из i слоёв во всех вершинах слоя применяются правила для обновления состояния ребра из текущей вершины в вершину предыдущего слоя, а затем на каждом из i слоёв (итерация по слоям здесь идёт в обратном порядке) во всех вершинах слоя применяются правила для обновления состояния ребра из текущей вершины в вершину следующего слоя.

#### Successive cancellation

Последовательный метод декодирования, оптимальный с точки зрения числа шагов. В фиксированной последовательности применяются правила на всех вершинах, правила на каждой вершине применяются фиксированное число раз.

Суммарное количество шагов в декодировании O(n log n), но это шаги последовательные и распараллелить этот алгоритм сложно.

#### Flooding

Оптимизация наивного метода, достигающая уменьшения количества шагов декодирования засчет сложной логики и использования информации о предыдущей итерации. Декодирование состоит из некоторого числа итераций. На каждой итерации параллельно применяются правила во всех внутренних вершинах, для которых на предыдущей итерации было обновлено какое-то инцидентное ребро.


### Сравнение методов декодирования

#### Критерий завершения декодирования

Изначально предподсчитывается корректно декодированный граф и при декодировании в начале каждой итерации проверяется, что граф ещё не был корректно декодирован. Конечно, при реальном декодировании так сделать нельзя, но для исследования скорости и работы различных методов декодирования такой способ самый простой и удобный. 

#### Метрики для сравнения работы методов декодирования

Работа методов декодирования сравнивается:

- с точки зрения количества шагов, требующихся для декодирования кода. Одним шагом считается либо применение правила для обновления состояния на ребре из вершины в вершину предыдущего слоя (левого ребра), либо применение правила для обновления состояния на ребре из вершины в вершину следующего слоя (правого ребра).

- с точки зрения количества параллельных шагов, требующихся для декодирования кода. Одним параллельным шагом считается произвольный набор шагов, которые могут применяться параллельно.
    - Для flooding и naive propagation один параллельный шаг соответствует итерации, так как в одной итерации этих алгоритмов правила применяются независимо.
    - Для conventional scheduling и round-trip scheduling один параллельный шаг соответствует одному внутреннему шагу на итерации, так как в вершинах на слое правила применяются независимо, а между слоями результат применения правил передается.
    - Для successive cancellation параллельных итераций как таковых нет, хотя в некоторых ситуациях несколько шагов можно сделать параллельно.

#### Сравнение

Для маленьких k есть возможность сравнить результат работы на всех вариантах переданного кода (сохраняя допущение модели, что корректно переданных значений n(1 - p)).

![diagram5_k3_final](results/diagram5_k3_final.png?raw=true)

Для больши́х k сравнивается результат работы на некотором количестве случайно сгенерированных итоговых данных.

![diagram5_k5_final](results/diagram5_k5_final.png?raw=true)

![diagram5_k8_final](results/diagram_256_200.png?raw=true)

